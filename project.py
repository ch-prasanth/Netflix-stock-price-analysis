# -*- coding: utf-8 -*-
"""PROJECT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_XBfQuyWHY1q5lJdWACKov9Olr2lpgh0

#**PRE**-**PROCESSING**
"""

import pandas as pd
import numpy as np
ds = '/content/Netflix Stock Price (1).xlsx'
df = pd.read_excel(ds)

df.head()

df.describe()

df.info()

df.duplicated().sum()

df.columns

df.isnull()

# Impute missing values
# Here, let's fill missing values with the mean of the respective columns
data_imputed = df.fillna(df.mean())

# Alternatively, you could choose to drop rows or columns with missing values
# Remove rows with missing values
data_removed_rows = df.dropna()

# Remove columns with missing values
data_removed_cols = df.dropna(axis=1)

# Display the preprocessed data after imputation
print("\nData after imputing missing values:")
print(data_imputed.head())

# Display the preprocessed data after removing rows with missing values
print("\nData after removing rows with missing values:")
print(data_removed_rows.head())

# Display the preprocessed data after removing columns with missing values
print("\nData after removing columns with missing values:")
print(data_removed_cols.head())

#calculate daily returns
df['Daily Returns']=df['Adj Close'].pct_change()

print("\nData with Daily Returns: ")
print(df)

# Calculating minmax normalization
df['Normalized_Close'] = (df['Close'] - df['Close'].min()) / (df['Close'].max() - df['Close'].min())
# Displaying the dataframe with normalized values
print("\nDataframe with Normalized Close Values:")
print(df)

from sklearn.preprocessing import StandardScaler, MinMaxScaler
print("Original Data:")
print(df.head())
scaler = StandardScaler()
scaled_data_standard = df.copy()
scaled_data_standard[df.columns[1:]] = scaler.fit_transform(df[df.columns[1:]])
print("\nData after scaling:")
print(scaled_data_standard.head())

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
df = pd.read_excel("/content/Netflix Stock Price (1).xlsx")
df['Date'] = pd.to_datetime(df['Date'])
# Set 'Date' column as the index
df.set_index('Date', inplace=True)
if 'Returns' not in df.columns:
  df['Returns'] = df['Close'].pct_change() * 100
# Plotting Open, High, Low, and Close prices
plt.figure(figsize=(14, 7))
plt.plot(df.index, df['Open'], label='Open')
plt.plot(df.index, df['High'], label='High')
plt.plot(df.index, df['Low'], label='Low')
plt.plot(df.index, df['Close'], label='Close')
plt.title('Netflix Stock Prices')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.grid(True)
plt.show()

# Plotting Volume
plt.figure(figsize=(14, 7))
plt.plot(df.index, df['Volume'], color='purple')
plt.title('Netflix Stock Volume')
plt.xlabel('Date')
plt.ylabel('Volume')
plt.grid(True)
plt.show()

# Distribution of Returns
plt.figure(figsize=(10, 6))
sns.histplot(df['Returns'].dropna(), bins=30, kde=True, color='skyblue')
plt.title('Distribution of Netflix Stock Returns')
plt.xlabel('Returns (%)')
plt.ylabel('Frequency')
plt.grid(True)
plt.show()

#4. Scatter plot of closing price against volume
plt.figure(figsize=(8, 6))
plt.scatter(df['Close'], df['Volume'])
plt.xlabel('Closing Price')
plt.ylabel('Volume Traded')
plt.title('Scatter Plot of Closing Price vs. Volume')
plt.show()















